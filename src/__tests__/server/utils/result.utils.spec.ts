import {
  describe, it, expect, vi, beforeEach,
} from 'vitest';
import { generateResultId, isValidResultId } from '@/server/utils/result.utils';

// Mock nanoid to provide predictable results
vi.mock('nanoid', () => ({
  customAlphabet: vi.fn().mockReturnValue(() => 'ABCD2345'),
}));

describe('Result Utilities', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe('generateResultId', () => {
    it('should generate an 8-character ID', () => {
      const id = generateResultId();
      expect(id).toHaveLength(8);
    });

    it('should return a consistent mocked ID', () => {
      const id = generateResultId();
      expect(id).toBe('ABCD2345');
    });

    it('should generate different IDs in production (unmocked)', async () => {
      // For this test, we'll temporarily restore the real implementation
      vi.unmock('nanoid');

      // Import the real functions directly for this test
      const { generateResultId: realGenerate } = await import('@/server/utils/result.utils');

      const id1 = realGenerate();
      const id2 = realGenerate();

      expect(id1).toHaveLength(8);
      expect(id2).toHaveLength(8);

      // Re-mock nanoid for subsequent tests
      vi.mock('nanoid', () => ({
        customAlphabet: vi.fn().mockReturnValue(() => 'ABCD2345'),
      }));
    });
  });

  describe('isValidResultId', () => {
    it('should return true for valid IDs', () => {
      // Test with various valid IDs
      expect(isValidResultId('ABCD2345')).toBe(true);
      expect(isValidResultId('23456789')).toBe(true);
      expect(isValidResultId('MNPQRSTU')).toBe(true);
      expect(isValidResultId('A2B3C4D5')).toBe(true);
    });

    it('should return false for IDs with wrong length', () => {
      expect(isValidResultId('ABC1234')).toBe(false); // Too short (7 chars)
      expect(isValidResultId('ABCD23456')).toBe(false); // Too long (9 chars)
      expect(isValidResultId('')).toBe(false); // Empty string
    });

    it('should return false for IDs with invalid characters', () => {
      // Test with characters not in the alphabet
      expect(isValidResultId('ABCD123O')).toBe(false); // Contains O (excluded)
      expect(isValidResultId('ABCI2345')).toBe(false); // Contains I (excluded)
      expect(isValidResultId('ABCD1-45')).toBe(false); // Contains - (excluded)
      expect(isValidResultId('abcd2345')).toBe(false); // Lowercase (excluded)
      expect(isValidResultId('ABCD 345')).toBe(false); // Contains space (excluded)
    });

    it('should validate the exact IDs generated by generateResultId', () => {
      const id = generateResultId();
      expect(isValidResultId(id)).toBe(true);
    });
  });

  describe('Integration', () => {
    it('should validate all valid characters from the alphabet', () => {
      const alphabet = '23456789ABCDEFGHJKMNPQRSTUVWXYZ';

      // Test each character by creating an 8-character ID with the same character
      alphabet.split('').forEach((char) => {
        const id = char.repeat(8);
        expect(isValidResultId(id)).toBe(true);
      });
    });

    it('should reject all excluded characters', () => {
      const excludedCharacters = '0O1Il';

      // Test each excluded character by creating an otherwise valid ID
      excludedCharacters.split('').forEach((char) => {
        const id = `AAAAAAA${char}`; // 7 valid chars + 1 invalid
        expect(isValidResultId(id)).toBe(false);
      });
    });
  });
});
